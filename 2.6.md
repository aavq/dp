Отличный блок, тут как раз важно не придумывать «как должно быть безопасно», а честно зафиксировать, **как оно реально настроено сейчас**.

Ниже — только **read-only** команды и куски кода, с пояснениями на русском. Их задача: собрать фактический **security model** по:

* Pod Security (runAsNonRoot, readOnlyRootFilesystem, capabilities, registries)
* mTLS & identity (PeerAuthentication, SPIFFE)
* AuthN/Z (RequestAuthentication, AuthorizationPolicy, egress-политики)
* Supply-chain & image security (версии образов, latest, allowed registries, политики Gatekeeper/Kyverno)

Использую переменные:

```bash
CTX=your-cluster-context      # kube-context кластера
NS_ISTIO=istio-d              # namespace с control plane
NS_GW=sm-gateways             # namespace с ingress/egress gateways
```

Добавляй `--context="$CTX"` в команды.

---

## 1. Pod security для Istio-подов

### 1.1. Снять securityContext всех контейнеров Istio

```bash
# Все Pod'ы в istio-d
kubectl --context="$CTX" get pods -n "$NS_ISTIO" -o yaml \
  > cluster-$CTX-istio-d-pods.yaml

# Все Pod'ы в sm-gateways
kubectl --context="$CTX" get pods -n "$NS_GW" -o yaml \
  > cluster-$CTX-sm-gateways-pods.yaml
```

**Что это даёт**

* Это полные YAML’ы Pod’ов Istio: дальше их можно анализировать локально (или в Git), не трогая кластер.
* В них есть `spec.containers[].securityContext` и `spec.initContainers[].securityContext`.

---

### 1.2. Быстрый обзор runAsNonRoot / readOnlyRootFilesystem / capabilities

Если можно использовать `jq`:

```bash
# Istio control-plane
kubectl --context="$CTX" get pods -n "$NS_ISTIO" -o json \
  | jq -r '.items[]
    | .metadata.name as $pod
    | .spec.containers[]
    | "\($pod)\t\(.name)\trunAsNonRoot=\(.securityContext.runAsNonRoot // "null")\treadOnlyRootFilesystem=\(.securityContext.readOnlyRootFilesystem // "null")\tcapabilities=\(.securityContext.capabilities // {})"'
```

Аналогично для gateways:

```bash
kubectl --context="$CTX" get pods -n "$NS_GW" -o json \
  | jq -r '.items[]
    | .metadata.name as $pod
    | .spec.containers[]
    | "\($pod)\t\(.name)\trunAsNonRoot=\(.securityContext.runAsNonRoot // "null")\treadOnlyRootFilesystem=\(.securityContext.readOnlyRootFilesystem // "null")\tcapabilities=\(.securityContext.capabilities // {})"'
```

**Пояснение**

* Команда **ничего не меняет**, только читает Pod’ы.
* На выходе ты сразу видишь:

  * где `runAsNonRoot=true/false/null`,
  * где `readOnlyRootFilesystem=true/false/null`,
  * какие capabilities добавлены/урезаны.
* Из этого можно честно написать в доке:
  «На данный момент не все Istio-поды имеют runAsNonRoot=true…» или наоборот.

Если `jq` под запретом — то же можно глазами из сохранённых YAML.

---

### 1.3. PodSecurity Admission / PodSecurityPolicy / namespace labels

#### Namespace labels (Pod Security Admission)

```bash
kubectl --context="$CTX" get ns "$NS_ISTIO" -o yaml \
  > cluster-$CTX-ns-istio-d.yaml

kubectl --context="$CTX" get ns "$NS_GW" -o yaml \
  > cluster-$CTX-ns-sm-gateways.yaml
```

**Пояснение**

* В `metadata.labels` будут видны метки `pod-security.kubernetes.io/enforce=*`, `audit=*`, `warn=*` (если вы используете встроенный Pod Security Admission).
* Это база для формулировки:
  «Namespaces istio-d / sm-gateways находятся под уровнем Pod Security X (baseline/restricted/privileged)…».

#### PodSecurityPolicy (если ещё используется)

```bash
kubectl --context="$CTX" get psp
kubectl --context="$CTX" get psp -o yaml > cluster-$CTX-psp.yaml
```

**Пояснение**

* Если PSP ещё есть — важно зафиксировать, какие политики влияют на Istio-поды (runAsUser, fsGroup, capabilities и т.п.).

---

## 2. mTLS & identity (PeerAuthentication, SPIFFE)

### 2.1. Собрать все PeerAuthentication

```bash
kubectl --context="$CTX" get peerauthentication -A
kubectl --context="$CTX" get peerauthentication -A -o yaml \
  > cluster-$CTX-istio-peerauthentications.yaml
```

**Пояснение**

* В `spec.mtls.mode` увидишь `STRICT` / `PERMISSIVE` / `DISABLE`:

  * если есть ресурс `peerauthentication` без `metadata.namespace` (в `istio-system` или в корне) — это mesh-wide default;
  * namespace- и workload-специфичные политики переопределяют default.
* Можно честно написать:
  «В прод-кластере mesh-wide mTLS: STRICT, но namespace X имеет PERMISSIVE…».

---

### 2.2. Проверить фактический режим TLS на уровне конкретного Pod’а

```bash
NS_APP=<namespace c приложением в mesh>
POD_APP=<pod-name>

istioctl --context="$CTX" x describe pod "$POD_APP" -n "$NS_APP"
```

**Пояснение**

* Эта команда (read-only) показывает:

  * что именно применилось к Pod’у: какой `PeerAuthentication`, `DestinationRule`,
  * какая TLS-политика будет использоваться (`ISTIO_MUTUAL`, `DISABLE` и т.п.).
* Это очень полезно, чтобы проверить, что написано в документации «mesh-wide mTLS STRICT» реально соблюдается на рабочих Pod’ах.

---

### 2.3. Проверить SPIFFE identity и trust-domain

1. **Через сертификаты сервера (sidecar)**

   ```bash
   # Посмотреть секреты, связанные с istio-cert
   kubectl --context="$CTX" get secret -n "$NS_APP" | grep istio
   ```

2. **Через Envoy (bootstrap/secret)**

   ```bash
   istioctl --context="$CTX" proxy-config secret "$POD_APP" -n "$NS_APP"
   ```

   или:

   ```bash
   istioctl --context="$CTX" proxy-config bootstrap "$POD_APP" -n "$NS_APP" \
     > cluster-$CTX-$NS_APP-$POD_APP-bootstrap.json
   ```

**Пояснение**

* В `proxy-config secret` / `bootstrap` можно увидеть SAN сертификата: `spiffe://<trust-domain>/ns/<namespace>/sa/<serviceaccount>`.
* `trust-domain` (например, `cluster.local` или что-то корпоративное) — это значение, которое стоит задокументировать в разделе mTLS & identity.

---

## 3. AuthN/Z: Ingress, In-mesh, Egress

### 3.1. Все RequestAuthentication (JWT / OIDC)

```bash
kubectl --context="$CTX" get requestauthentication -A
kubectl --context="$CTX" get requestauthentication -A -o yaml \
  > cluster-$CTX-istio-requestauthentication.yaml
```

**Пояснение**

* В этих ресурсах видно:

  * какие `issuer` (URL IdP),
  * какие `jwksUri`,
  * какие `selector` (какие workloads/gateways попадают).
* Это прямое основание для текста:
  «HTTP(S) ingress интегрирован с OIDC-IdP X, JWT валидируются на ingress gateway через RequestAuthentication …».

---

### 3.2. Все AuthorizationPolicy

```bash
kubectl --context="$CTX" get authorizationpolicy -A
kubectl --context="$CTX" get authorizationpolicy -A -o yaml \
  > cluster-$CTX-istio-authorizationpolicies.yaml
```

**Пояснение**

* По этим YAML’ам можно:

  * увидеть policies для ingress (обычно в `sm-gateways` или в namespace’ах, где сервисы требуют определённых JWT claims),
  * policies для внутримэшевого доступа (ограничение по `source.namespace`, `source.principal`),
  * policies для egress gateway (выбор `source` по serviceAccount gateway’ев и `destination` по `host`/`port`).
* На основе этого описываешь: «Разграничение прав в mesh реализовано через AuthorizationPolicy …».

---

### 3.3. EnvoyFilter / OIDC-фильтры на ingress gateway

Если вы используете `envoy.ext_authz`/`oauth2`/другие фильтры:

```bash
kubectl --context="$CTX" get envoyfilter -A
kubectl --context="$CTX" get envoyfilter -A -o yaml \
  > cluster-$CTX-istio-envoyfilters.yaml
```

**Пояснение**

* Здесь видно:

  * фильтры для интеграции с внешним IdP (OIDC/OAuth2),
  * фильтры для дополнительного логирования/аутентификации.
* Это часть секции AuthN, которую обычными `RequestAuthentication`/`AuthorizationPolicy` не всегда охватишь.

---

### 3.4. Egress: AuthorizationPolicy + ServiceEntry

Все ServiceEntry:

```bash
kubectl --context="$CTX" get serviceentry -A
kubectl --context="$CTX" get serviceentry -A -o yaml \
  > cluster-$CTX-istio-serviceentries.yaml
```

**Пояснение**

* Это список всех внешних хостов и портов, разрешённых через mesh (включая трафик через egress gateway).
* Сопоставив ServiceEntry с AuthorizationPolicy (из 3.2), можно задокументировать:

  * какие внешние системы доступны,
  * с каких namespaces/serviceAccounts,
  * через egress gateway или напрямую.

---

### 3.5. Mesh-wide outbound policy (`REGISTRY_ONLY` vs `ALLOW_ANY`)

```bash
istioctl --context="$CTX" mesh-config \
  > cluster-$CTX-istio-mesh-config.txt
```

**Пояснение**

* В этом выводе есть `outboundTrafficPolicy.mode`: `REGISTRY_ONLY` или `ALLOW_ANY`.
* Это критично для security model:

  * `REGISTRY_ONLY` → outbound только к известным ServiceEntry/Service,
  * `ALLOW_ANY` → Envoy может ходить куда угодно (подконтрольно только firewall’ам).

---

## 4. Supply-chain & image security

### 4.1. Список всех образов Istio и gateways

Control-plane:

```bash
kubectl --context="$CTX" get deploy -n "$NS_ISTIO" -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{range .spec.template.spec.containers[*]}{.image}{" "}{end}{"\n"}{end}' \
  > cluster-$CTX-istio-d-images.txt
```

Gateways:

```bash
kubectl --context="$CTX" get deploy -n "$NS_GW" -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{range .spec.template.spec.containers[*]}{.image}{" "}{end}{"\n"}{end}' \
  > cluster-$CTX-sm-gateways-images.txt
```

**Пояснение**

* Вывод покажет реальный список образов: `registry.company/istio/proxyv2:1.21.3`, `docker.io/istio/pilot:1.20.0` и т.п.
* По нему можно:

  * проверить, нет ли `:latest`,
  * какие реестры используются (`docker.io`, `gcr.io`, `corp-registry`),
  * привести список только версий Istio (для документации).

---

### 4.2. Поиск `:latest` и нефиксированных тегов

```bash
# Все образы Istio (control-plane + gateways)
cat cluster-$CTX-istio-d-images.txt cluster-$CTX-sm-gateways-images.txt \
  | awk '{for (i=2; i<=NF; i++) print $i}' | sort -u > cluster-$CTX-istio-all-images.txt

# Проверить наличие тегов :latest
grep ':latest' cluster-$CTX-istio-all-images.txt || echo "no :latest tags found"
```

**Пояснение**

* Если `grep` ничего не выводит — хорошо, можно уверенно писать: «Образы Istio не используют тег :latest».
* Если что-то найдётся — это предмет для плана улучшений.

Если хочешь отловить образы **без тега** (редко, но бывает: `registry/app@sha256:...` — это нормально; а вот просто `image` без `:` — уже вопрос):

```bash
grep -v '@sha256:' cluster-$CTX-istio-all-images.txt \
  | awk -F: 'NF==1 {print "No tag:", $0}'
```

---

### 4.3. Allowed registries: что реально используется

```bash
awk -F/ '{print $1}' cluster-$CTX-istio-all-images.txt | sort -u \
  > cluster-$CTX-istio-image-registries.txt
```

**Пояснение**

* Это список реальных реестров, откуда тянутся образы для Istio.
* Его удобно сравнивать с политиками (Gatekeeper/Kyverno), которые задают allowed registries.

---

### 4.4. Gatekeeper / Kyverno политики supply-chain (allowed registries, no latest, runAsNonRoot)

#### Gatekeeper

```bash
kubectl --context="$CTX" get constrainttemplates.templates.gatekeeper.sh -A -o yaml \
  > cluster-$CTX-gatekeeper-constrainttemplates.yaml

kubectl --context="$CTX" get constraints.gatekeeper.sh -A -o yaml \
  > cluster-$CTX-gatekeeper-constraints.yaml 2>/dev/null || true
```

> В зависимости от версии, типы constraints могут называться `k8sallowedrepos.constraints.gatekeeper.sh`, `k8srequiredlabels.constraints.gatekeeper.sh` и т.п. Можно явно:

```bash
kubectl --context="$CTX" api-resources | grep gatekeeper
```

**Пояснение**

* В ConstraintTemplate/Constraint можно найти:

  * политики по allowed registries (часто `k8sallowedrepos`),
  * запрет `:latest` и других непинованных тегов,
  * требование `runAsNonRoot`, `readOnlyRootFilesystem`.
* Это база для строки: «Supply-chain контролируется через Gatekeeper-политику X, которая запрещает образы из неразрешённых реестров и теги :latest…».

#### Kyverno

```bash
kubectl --context="$CTX" get cpol -A -o yaml \
  > cluster-$CTX-kyverno-clusterpolicies.yaml

kubectl --context="$CTX" get pol -A -o yaml \
  > cluster-$CTX-kyverno-policies.yaml
```

**Пояснение**

* В Kyverno-политиках ищутся правила `validate`/`mutate` с match на Pod/Deployment, где:

  * проверяется `.spec.containers[].image`,
  * проверяется `.securityContext.runAsNonRoot`,
  * запрещаются теги `:latest`.
* Эти YAML — материал для «человеческого» описания: какие именно supply-chain правила у вас включены.

---

Если хочешь, дальше можно сделать так:

1. Ты запускаешь часть этих команд на одном кластерe (можно только на DEV/UAT).
2. Обезличиваешь (убираешь конкретные хостнеймы/реестры, если нужно).
3. Кидаешь сюда фрагменты вывода (`peerauthentication`, куски AuthorizationPolicy, пример Pod’а Istio с securityContext, список образов).

Я помогу по этим данным собрать уже **готовый текст** раздела 2.6 *Security model* именно под вашу фактическую конфигурацию, с явным указанием, что уже хорошо, а что пока «planned / target state».
